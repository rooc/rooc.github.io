<?xml version="1.0"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
	<channel>
		<title><![CDATA[Rooc]]></title>
		<description><![CDATA[Блог веб-разработчика, CSS3, HTML, HTML5, jQuery]]></description>
		<link>http://rooc.me</link>
		<lastBuildDate>
			
			Mon Aug 01 2016 14:10:27 GMT+0300 (EEST)
		</lastBuildDate>
		<atom:link href="rooc.github/rss/posts.xml" rel="self" type="application/rss+xml"/>
		<author><![CDATA[rooc]]></author>

		
		
		

		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
			

		
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
		
		
			<item>
				<title>Модульный CSS и селекторы атрибутов</title>
				<link>rooc.githubblog/attribute-modules.html</link>
				<description>
					&lt;p&gt;Несколько месяцев назад мне попалась &lt;a href=&#34;http://csswizardry.com/2014/05/grouping-related-classes-in-your-markup/&#34;&gt;статья Гарри Робертса&lt;/a&gt; в которой он представил интересную концепцию работы с сопряженными классами в CSS. В этой статье он предложил использовать символы &lt;code&gt;[ ]&lt;/code&gt; для группировки классов для того чтобы быстро распознать их смысл при беглом просмотре. Он приводит данный пример, утверждая что в таком виде декларация стилей становится более &amp;quot;распознавабельной&amp;quot;:&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;[ foo  foo--bar ]  [ baz  baz--foo ]&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Признаюсь, сначала я принял такой подход в штыки. Идея имен классов с именами &lt;code&gt;[ ]&lt;/code&gt; которым к тому же не соотвествуют никакие стили, да еще повторяются внутри одного атрибута, которые имеют смысл только для человека и не для браузера, выглядит очень странной. Я собственно и по прежнему думаю также, но тем не менее, это заставило меня задуматься о верстке и семантике поглубже, поэтому - спасибо Гарри!&lt;/p&gt;
&lt;p&gt;Пока я думал об этом я нашел что разные люди предлагали похожие подходы, например использовать &lt;code&gt;/&lt;/code&gt; (&lt;a href=&#34;http://beneverard.co.uk/blog/using-slashes-within-the-html-class-attribute/&#34;&gt;Ben Everard&lt;/a&gt;), или &lt;code&gt;|&lt;/code&gt; (&lt;a href=&#34;https://twitter.com/sn0lan/status/439384690680942592/&#34;&gt;Steven Nolan&lt;/a&gt;), но все эти способы оставляют ощущение искусственности.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Как так вышло что у вас так много классов что вам нужны новые классы чтобы сделать их читабельными?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Короче говоря это сумашествие. Хорошо читабельный HTML это конечно достойная цель, но такого рода приемы говорят что что то у нас фундаментально пошло не так с наименованием стилей.&lt;/p&gt;
&lt;h2&gt;Больше классов против меньше классов&lt;/h2&gt;&lt;p&gt;Странная штука, но несмотря на то что обилие классов в разметке кажется мне не нормальным, люди типа Гарри чертовски убедительны. Исходя из принципов OOCSS или &lt;a href=&#34;http://csswizardry.com/2012/04/the-single-responsibility-principle-applied-to-css/&#34;&gt;Single Responsibility Principle&lt;/a&gt;, а также из моего личного опыта работы со сложными сайтами, я могу сказать что есть определенная ценность в &amp;quot;дроблении&amp;quot;  стилей, но тем не менее только недавно я нашел способ который меня удовлетворил.&lt;/p&gt;
&lt;p&gt;Перед этим я адаптировал версию методологии БЭМ которая делает акцент на изоляции а не на повторном использовании - каждый новый блок по умолчанию не наследует никаких стилей, позволяя компоненту разрабатываться изолированно и избежать риска испортить что либо в другом месте сайта.
Но недостаток такого подохода в том что в итоге вы обнаруживаете что у вас 10 различных стилей для ссылок, 12 оттенков голубого, 18 слегка отличающихся стилей кнопок. Николь Саливан, создатель OOCS, в своей фантастической &lt;a href=&#34;https://www.youtube.com/watch?v=0NDyopLKE1w&#34;&gt;презентации&lt;/a&gt; в прошлом году в Мельбурне рассказала как часто такое случается и как это исправлять.&lt;/p&gt;
&lt;p&gt;Для меня выходом, который меня устраивал, было использовать возможности препроцессоров для того чтобы совместить атомарность БЭМ и согласованность OOCSS. К примеру, вместо такого:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a class=&amp;#39;btn large rounded&amp;#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.btn { /* button styles */ }
.large { /* global large-type modifier */ }
.rounded { /* global rounded-border modifier */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;имеем такое:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a class=&amp;#39;btn btn--large btn--rounded&amp;#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-scss&#34;&gt;.btn { /* button styles */ }
.btn--large {
  @extend %large-type;
}
.btn--rounded {
  @extend %rounded-borders;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В итоге я пришел к тому что у меня была кучка файлов типа &lt;code&gt;_typography.scss&lt;/code&gt;, &lt;code&gt;_brand.scss&lt;/code&gt;, которые позволяли мне более менее поддерживать фрагментацию и в то же время изоляцию отдельных компонентов. И все было ОК, до поры до времени.&lt;/p&gt;
&lt;h2&gt;Модификаторы: как М ломает БЭМ&lt;/h2&gt;&lt;p&gt;Если вы изучаете вопрос наименования классов в CSS и поддержки стилей, вы неизбежно натолкнетесь на отличную статью Николаса Галахера  &lt;a href=&#34;http://nicolasgallagher.com/about-html-semantics-front-end-architecture/&#34;&gt;&amp;quot;About HTML semantics and front-end architecture&amp;quot;&lt;/a&gt;. Одна часть особенно привлекла мое внимание, то что он называет шаблоном &amp;quot;один класс&amp;quot; против &amp;quot;множественные классы&amp;quot;. В вашей разметке потенциально может быть два таких варианта:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a class=&amp;#39;btn--large&amp;#39;&amp;gt; &amp;lt;!-- Single class --&amp;gt;
&amp;lt;a class=&amp;#39;btn btn--large&amp;#39;&amp;gt; &amp;lt;!-- Multi class --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Это соответствует двум подходам в CSS:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/* Single class */
.btn, .btn--large { /* base button styles */ }
.btn--large { /* large button styles */ }

/* Multi class */
.btn { /* base button styles */ }
.btn--large { /* large button styles */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Разница тут в том самостоятелен ли класс &lt;code&gt;btn--large&lt;/code&gt; или он требует присутствия родительского класса &lt;code&gt;btn&lt;/code&gt;. В шаблоне &amp;quot;один класс&amp;quot; он самостоятелен, это выглядит проще и удобнее, и страхует от случая когда вы забыли вписать второй класс. Плюс с функционалом препроцессоров &lt;code&gt;@extend&lt;/code&gt; это выглядит совсем просто. Но, такой подход подвержен серьезному недостатку.&lt;/p&gt;
&lt;p&gt;##Контекстные модификации&lt;/p&gt;
&lt;p&gt;Представим что все кнопки на сайте имеют какой то фоновый цвет, за исключением тех которые находятся в панели навигации в шапке сайта. В случае паттерна &amp;quot;множественные классы&amp;quot; вы добираетесь до кнопок в навигации так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;header &amp;gt; nav &amp;gt; .btn { background: none; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В случае если вы используете паттерн с одним классом вы не знаете точно какой вариант кнопки вам надо перекрыть поэтому мы вынуждены поступать так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scss&#34;&gt;header &amp;gt; nav {
  .btn, .btn--large, .btn--rounded { background: none; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как можно догадаться это не идеально, каждый раз когда вы добавляете новый модификатор кнопки вам надо не забыть и вписать сюда этот класс. Это все не очень здраво, поэтому многие считают что надо вернуться к варианту множественных классов. (&lt;a href=&#34;http://nicolasgallagher.com/about-html-semantics-front-end-architecture/&#34;&gt;Nicholas Gallagher&lt;/a&gt;, &lt;a href=&#34;http://bensmithett.com/bem-modifiers-multiple-classes-vs-extend/&#34;&gt;Ben Smithett&lt;/a&gt;). Встречал и другие альтернативные варианты, метод &lt;a href=&#34;http://viget.com/extend/bem-multiple-modifiers-and-experimenting-with-attribute-selectors&#34;&gt;Томми Маршала&lt;/a&gt; или &lt;a href=&#34;http://benfrain.com/multiple-classes-ui-component-variations-wrong/&#34;&gt;Бена Фрейна&lt;/a&gt;, которые используют селектор атрибута &lt;code&gt;^=&lt;/code&gt; которым можно проверить начинается ли атрибут определенной строкой, например:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a class=&amp;#39;btn--large&amp;#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;[class^=&amp;#39;btn&amp;#39;] { /* базовые стили кнопок */ }
.btn--large { /* модификатор для большой кнопки */ }
header &amp;gt; nav &amp;gt; [class^=&amp;#39;btn&amp;#39;] { /* Перекрывает все кнопки */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Таким способом легко перекрыть стили шаблона &amp;quot;один класс&amp;quot;, но все таки это слишком хрупкий способ чтобы рассматривать его серьезной альтернативой. Если к примеру у вас в стилях каким то образом первый класс оказался не &lt;code&gt;btn&lt;/code&gt;  то все ломается. &lt;/p&gt;
&lt;p&gt;Я конечно ценю изобретательность такого подхода, но это тупик. Это как раз то место где я застрял, до тех пор пока мне не пришло в голову кое что.&lt;/p&gt;
&lt;h1&gt;##Какого &lt;/h1&gt;&lt;p&gt;[class^=&amp;#39;btn&amp;#39;] { /&lt;em&gt; base button styles &lt;/em&gt;/ }
.btn--large { /&lt;em&gt; large button styles &lt;/em&gt;/ }
header &amp;gt; nav &amp;gt; [class^=&amp;#39;btn&amp;#39;] { /&lt;em&gt; Overrides for all buttons &lt;/em&gt;/ }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Это конечно удобный вариант для метода &amp;quot;один класс&amp;quot; но все таки это слишком хрупкая конструкция чтобы быть серьезной альтернативой. Если какой то другой класс окажется перед `btn--large` то вся конструкция летит к чертям. Плюс ко всему нет ясного способа как в этом случае иметь дело с модификатором модификатора типа `btn--large--rounded`.

Я ценю изобретательность этого метода но это тупик. И это то место где я застрял до момента когда кое что пришло мне в голову.

##А чего мы вообще приклеились &amp;lt;br&amp;gt; к атрибуту class?

Пардон за мою тупость но кто нибудь может доказать мне что `class` это единственный атрибут который мы можем использовать для селекторов стилей? Вот что говорит [спецификация HTML](http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#classes):

&amp;gt; **3.2.5.7 The class attribute**   
&amp;gt;
&amp;gt; Атрибут, если определен, должен иметь значение, состоящее из группы разделенных пробелом
&amp;gt; имен представляющих различные классы к которым принадлежит элемент.  
&amp;gt;
&amp;gt; Нет никаких ограничений какие имена может использовать автор но рекомендуется использовать 
&amp;gt; имена которые описывают природу или значение содержимого а не желаемый внешний вид 
&amp;gt; содержимого.

Ну да, это чудесно что мы используем атрибут класс для описания &amp;quot;природы содержимого&amp;quot;, но все таки ощущение такое что мы хотим от него больше чем он может дать. Этот многострадальный атрибут содержит все, начиная от громоздких БЭМ имен типа `primary-nav__sub-nav--current` или вспомогательных классов типа `u-textTruncate` или `left clearfix`, до джаваскрипт указателей `js-whatevs`, в итоге мы тратим кучу времени на придумывание имен которые не конфликтуют один с другим и тем не менее читабельны.

С этим можно справится при помощи дисциплины и соглашений и с помощью разных техник, но правда в том что мы работаем в глобальном пространстве имен, и никакие соглашения не могут это изменить. А это как раз то что делает АМ особым.

Но прежде чем мы поговорим об этом нам нужно освежить одну не очень известную фишку в CSS.

##Магический селектор ~=

Оказывается что браузеры аж с времен IE7 поддерживают мощнецкое правило называемое **селектор атрибутов разделенных пробелом**, описанную [тут на CSS Tricks](http://css-tricks.com/attribute-selectors/#rel-space). Он цепляет произвольные значения атрибутов, разделенных пробеламы, так как будто это и есть классы. К примеры следующие две строки идентичны:

```css
.dat-class { /* dem styles */ };
[class~=&amp;#39;dat-class&amp;#39;] { /* dem styles */ };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Точно также как для &lt;code&gt;&amp;lt;div class=&amp;quot;a b c &amp;quot;&amp;gt;&lt;/code&gt; не имеет значения в каком порядке стоят a, b или с, или что еще есть помимо них, также это не важно для селектора &lt;code&gt;~=&lt;/code&gt;. Но этот селектор не ограничен атрибутом class, он работает точно также с любым другим атрибутом. И это ключевой момент в новом подходе.&lt;/p&gt;
&lt;p&gt;&amp;quot;Модули атрибутов&amp;quot;, или АМ, это по сути определение пространства имен в которых живут стили. Начнем с простого примера, колонки:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;column-12&amp;quot;&amp;gt;Full&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;column-4&amp;quot;&amp;gt;Thirds&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;column-4&amp;quot;&amp;gt;Thirds&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;column-4&amp;quot;&amp;gt;Thirds&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.row { /* max-width, clearfixes */ }
.column-1 { /* 1/12th width, floated */ }
.column-2 { /* 1/6th width, floated */ }
.column-3 { /* 1/4th width, floated */ }
.column-4 { /* 1/3rd width, floated */ }
.column-5 { /* 5/12th width, floated */ }
/* etc */
.column-12 { /* 100% width, floated */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь построим это же самое на АМ. У нас есть два модуля, строки(rows) и колонки(columns). У строки нет вариаций, у колонок их 12.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div am-Row&amp;gt;
    &amp;lt;div am-Column=&amp;quot;12&amp;quot;&amp;gt;Full&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div am-Row&amp;gt;
    &amp;lt;div am-Column=&amp;quot;4&amp;quot;&amp;gt;Thirds&amp;lt;/div&amp;gt;
    &amp;lt;div am-Column=&amp;quot;4&amp;quot;&amp;gt;Thirds&amp;lt;/div&amp;gt;
    &amp;lt;div am-Column=&amp;quot;4&amp;quot;&amp;gt;Thirds&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;[am-Row] { /* max-width, clearfixes */ }
[am-Column~=&amp;quot;1&amp;quot;] { /* 1/12th width, floated */ }
[am-Column~=&amp;quot;2&amp;quot;] { /* 1/6th width, floated */ }
[am-Column~=&amp;quot;3&amp;quot;] { /* 1/4th width, floated */ }
[am-Column~=&amp;quot;4&amp;quot;] { /* 1/3rd width, floated */ }
[am-Column~=&amp;quot;5&amp;quot;] { /* 5/12th width, floated */ }
/* etc */
[am-Column~=&amp;quot;12&amp;quot;] { /* 100% width, floated */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Первое что вы наверно заметили это префикс &lt;code&gt;am-&lt;/code&gt;. Это важно чтобы не создать конфликтов с другими существующими атрибутами. Конечно можно использовать любой префикс, я пробовал &lt;code&gt;ui-&lt;/code&gt;, &lt;code&gt;css-&lt;/code&gt; и другие, но оставился на &lt;code&gt;am-&lt;/code&gt; для данных примеров. Если валидность HTML критична для вас то можно использовать атрибут в виде &lt;code&gt;data-&lt;/code&gt;, смысл тот же.&lt;/p&gt;
&lt;p&gt;Второе что вы наверно заметили это значения атрибутов типа &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;. Если бы это были имена классов это было бы ужасно, они слишком общеупотребительные и шансы конфликтов велики. Но поскольку мы определили свое собственное пространство имен, мы можем использовать максимально короткие имена.&lt;/p&gt;
&lt;p&gt;##Гибкость значений атрибутов&lt;/p&gt;
&lt;p&gt;На данный момент плюсы от нового способа минорные. Но поскольку каждый модуль задает свое пространство имен, давайте попробуем немного другую схему значений:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div am-Row&amp;gt;
    &amp;lt;div am-Column&amp;gt;Full&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div am-Row&amp;gt;
    &amp;lt;div am-Column=&amp;quot;1/3&amp;quot;&amp;gt;Thirds&amp;lt;/div&amp;gt;
    &amp;lt;div am-Column=&amp;quot;1/3&amp;quot;&amp;gt;Thirds&amp;lt;/div&amp;gt;
    &amp;lt;div am-Column=&amp;quot;1/3&amp;quot;&amp;gt;Thirds&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;[am-Row] { /* max-width, clearfixes */ }
[am-Column] { /* 100% width, floated */ }
[am-Column~=&amp;quot;1/12&amp;quot;] { /* 1/12th width */ }
[am-Column~=&amp;quot;1/6&amp;quot;] { /* 1/6th width */ }
[am-Column~=&amp;quot;1/4&amp;quot;] { /* 1/4th width */ }
[am-Column~=&amp;quot;1/3&amp;quot;] { /* 1/3rd width */ }
[am-Column~=&amp;quot;5/12&amp;quot;] { /* 5/12ths width */ }
/* etc */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь мы можем легко использовать имена для наших конкретных нужд, ширина колонки 1/3 сразу же говорит что это значит, тогда как например 4 предполагает что мы помним что используем 12 колоночную сетку. Атрибут &lt;code&gt;column&lt;/code&gt; без значения например означает колонку 100% ширины, и как бонус мы можем в атрибут без значения перенести всю повторяемую логику,  (&lt;code&gt;float: left&lt;/code&gt;) например.&lt;/p&gt;
&lt;p&gt;##Определение стилей для атрибута и для его значений&lt;/p&gt;
&lt;p&gt;Это главная прелесть этого подхода. Наличие атрибута, например &lt;code&gt;am-Button&lt;/code&gt;, само по себе может быть застилено. Конкретное значение атрибута модифицирует эти базовые стили.&lt;/p&gt;
&lt;p&gt;В примере с сеткой выше мы делаем именно это: разметка &lt;code&gt;am-Column = &amp;quot;1/3&amp;quot;&lt;/code&gt; подпадает сразу под оба селектора, и &lt;code&gt;[am-Column]&lt;/code&gt;  и &lt;code&gt;[am-Column~=&amp;quot;1/3&amp;quot;]&lt;/code&gt; , поэтому результат это базовые стили плюс вариации. Это избавляет от копирования классов или использования функционала &lt;code&gt;@extend&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&amp;quot;Без классовый&amp;quot; подход к БЕМ модификаторам&lt;/h2&gt;&lt;p&gt;Вернемся к спору между шаблоном &amp;quot;один класс&amp;quot; и &amp;quot;множественные классы&amp;quot;. АМ предлагает способ без классов. Ну к примеру, для случая четырех вариантов кнопок разметка выглядит так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a am-Button&amp;gt;Normal button&amp;lt;/a&amp;gt;
&amp;lt;a am-Button=&amp;#39;large&amp;#39;&amp;gt;Large button&amp;lt;/a&amp;gt;
&amp;lt;a am-Button=&amp;#39;rounded&amp;#39;&amp;gt;Rounded button&amp;lt;/a&amp;gt;
&amp;lt;a am-Button=&amp;#39;large rounded&amp;#39;&amp;gt;Large rounded button&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;[am-Button] { /* base button styles */ }
[am-Button~=&amp;quot;large&amp;quot;] { /* large button styles */ }
[am-Button~=&amp;quot;rounded&amp;quot;] { /* round button styles */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;При помощи атрибута &lt;code&gt;am-Button&lt;/code&gt;, мы можем разделить стили которые общие для всех кнопок и стили которые делают кнопку большой, или стили для скругленной кнопки. Мы можем не только спокойно комбинировать вариации кнопок (&lt;code&gt;am-Button = &amp;quot;large rounded&amp;quot;&lt;/code&gt;), но мы можем выбирать сам атрибут для любых контекстных модификаций:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;header &amp;gt; nav &amp;gt; [am-Button] { background: none; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Не важно какой вариант кнопки у нас используется, или как много вариантов мы решим создать, мы можем выбрать все кнопки одним селектором &lt;code&gt;[am-Button]&lt;/code&gt;, поэтому мы можем быть уверены что модификации будут валидными.&lt;/p&gt;
&lt;h2&gt;AMCSS проект&lt;/h2&gt;&lt;p&gt;Я (&lt;a href=&#34;http://glenmaddern.com/&#34;&gt;Glen Maddern&lt;/a&gt;), &lt;a href=&#34;http://germanforblack.com/&#34;&gt;Ben Schwarz&lt;/a&gt; и &lt;a href=&#34;http://bensmithett.com/&#34;&gt;Ben Smithett&lt;/a&gt; начали работу над спецификацией АМ. Если вы хотите узнать больше как эта техника расширяет блоки, элементы, точки перехода (breakpoints) и больше, поднимайте пожалуйста свой &lt;a href=&#34;https://github.com/amcss/attribute-module-specification/issues&#34;&gt;вопрос&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Также мы сделали сайт с документацией, с разными примерами как использовать АМ, &lt;a href=&#34;http://amcss.github.io/&#34;&gt;amcss.github.io&lt;/a&gt;. Если вам интересно внести свой вклад, сделать примеры или вы хотите показать нам свои варианты АМ библиотек, пишите нам на &lt;a href=&#34;https://github.com/amcss/amcss.github.io&#34;&gt;Гитхаб&lt;/a&gt;.&lt;/p&gt;

				</description>
				<dc:creator><![CDATA[rooc]]></dc:creator>
				<pubDate>
					Sat Dec 13 2014 02:00:00 GMT+0200 (EET)
				</pubDate>
			</item>
			
		
			<item>
				<title>Основы работы с SVG</title>
				<link>rooc.githubblog/using-svg.html</link>
				<description>
					&lt;p&gt;SVG это формат векторной графики, буквально означающий &lt;strong&gt;Масштабируемая Векторная Графика&lt;/strong&gt;. Собственно это то с чем вы работаете в Иллюстраторе. SVG использовать в вебе довольно просто но тем не менее есть куча того что необходимо знать.&lt;!-- more --&gt;&lt;/p&gt;
&lt;p&gt;###Зачем это вообще все?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Маленький размер который к тому же хорошо сжимается&lt;/li&gt;
&lt;li&gt;Масштабирование без потери четкости (за исключением очень маленьких размеров)&lt;/li&gt;
&lt;li&gt;Отлично выглядит на ретине&lt;/li&gt;
&lt;li&gt;Легко управляем, фильтры, интерактивность&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###Где взять SVG графику&lt;/p&gt;
&lt;p&gt;Нарисуйте что-нибудь в Иллюстраторе, вот к примеру типа такого:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.css-tricks.com/wp-content/uploads/2013/03/kiwi.png&#34; alt=&#34;Kiwi&#34; title=&#34;figure&#34;&gt;&lt;/p&gt;
&lt;p&gt;Обратите внимание что картинка обрезана четко по краю изображения. Полотно, или основа, имеет значение в svg точно также как в png или jpg.&lt;/p&gt;
&lt;p&gt;Графику в Иллюстраторе можно сохранять как svg файл.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.css-tricks.com/wp-content/uploads/2013/03/save-as-svg.png&#34; alt=&#34;save as&#34; title=&#34;figure&#34;&gt;&lt;/p&gt;
&lt;p&gt;При сохранении есть кучка настроек но я честно говоря особо в них не разбираюсь. На эту тему есть целая &lt;a href=&#34;http://www.w3.org/TR/SVGMobile/&#34;&gt;спецификация&lt;/a&gt;. Сохранение как версия 1.1 работает нормально как по мне.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.css-tricks.com/wp-content/uploads/2013/03/svg-options.png&#34; alt=&#34;options&#34; title=&#34;figure&#34;&gt;&lt;/p&gt;
&lt;p&gt;Интересный момент здесь в том что можно либо сохранить файл либо выбрать &lt;code&gt;SVG Code...&lt;/code&gt; и при этом откроется текстовый редактор с кодом svg.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.css-tricks.com/wp-content/uploads/2013/03/svg-code.png&#34; alt=&#34;code&#34; title=&#34;figure&#34;&gt;&lt;/p&gt;
&lt;p&gt;Оба варианта полезны.&lt;/p&gt;
&lt;p&gt;##Использование svg как &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;После сохранения svg файла, его можно напрямую использовать в html.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;img src=&amp;quot;kiwi.svg&amp;quot; alt=&amp;quot;Kiwi standing on oval&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В иллюстраторе полотно было размером 612 на 502 пиксела.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.css-tricks.com/wp-content/uploads/2013/03/artboard.png&#34; alt=&#34;illustrator&#34; title=&#34;figure&#34;&gt;&lt;/p&gt;
&lt;p&gt;Именно такого размера картинка будет на странице если ей никак не задавать размеры. Можно просто поменять размер точно также как это делается для png или jpeg изменяя &lt;code&gt;width&lt;/code&gt; и &lt;code&gt;height&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;jsbin-embed&#34; href=&#34;http://jsbin.com/caret/1/embed?output&#34;&gt;JS Bin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;###Поддержка браузерами&lt;/p&gt;
&lt;p&gt;Использование svg в элементе img поддерживают &lt;a href=&#34;http://caniuse.com/#feat=svg-img&#34;&gt;такие браузеры&lt;/a&gt;, а точнее - это работает везде кроме Эксплорер 8 и ниже и Андроид 2.3 и ниже.&lt;/p&gt;
&lt;p&gt;Если вы хотите использовать svg но также нужно как то поддерживать эти браузеры то есть несколько вариантов. О нескольких разных вариантах я рассказывал на &lt;a href=&#34;http://css-tricks.com/workshop-notes-webstock-13/&#34;&gt;разных&lt;/a&gt; &lt;a href=&#34;http://css-tricks.com/workshop-notes-from-incontrol-hawaii/&#34;&gt;семинарах&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Один из вариантов это проверить поддержку SVG при помощи Modernizr и поменять атрибут &lt;code&gt;src&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (!Modernizr.svg) {
  $(&amp;quot;.logo img&amp;quot;).attr(&amp;quot;src&amp;quot;, &amp;quot;images/logo.png&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;David Bushell предложил очень &lt;a href=&#34;http://dbushell.com/2013/02/04/a-primer-to-front-end-svg-hacking/&#34;&gt;простую альтернативу&lt;/a&gt;, если вас не смущает джаваскрипт код в html:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;img src=&amp;quot;image.svg&amp;quot; onerror=&amp;quot;this.onerror=null; this.src=&amp;#39;image.png&amp;#39;&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Есть еще такой инструмент - &lt;a href=&#34;http://benhowdle.im/svgeezy/&#34;&gt;SVGeezy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;##SVG как фоновая картинка&lt;/p&gt;
&lt;p&gt;Точно также как обычные картинки можно применять svg как фоновую картинку.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;/&amp;quot; class=&amp;quot;logo&amp;quot;&amp;gt;
  Kiwi Corp
&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.logo {
    display: block;
    text-indent: -9999px;
    width: 100px;
    height: 82px;
    background: url(kiwi.svg);
    background-size: 100px 82px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Обратите внимание что размер фоновой картинки установлен в размер самого элемента &lt;code&gt;.logo&lt;/code&gt;. Это необходимо, иначе мы увидим только верхний левый фрагмент намного большей исходной svg картинки. Эти размеры должны учитывать соотношение сторон оригинальной картинки. Но не забывайте что можно просто использовать &lt;code&gt;background-size: contain&lt;/code&gt; если вы не знаете точных размеров родительского элемента.&lt;/p&gt;
&lt;p&gt;###Поддержка браузерами&lt;/p&gt;
&lt;p&gt;Использование svg для фоновых картинок имеет похожую на SVG для картинок &lt;a href=&#34;http://caniuse.com/#feat=svg-css&#34;&gt;поддержку&lt;/a&gt;. Проблемы только с ИЕ 8 и ниже и андроид 2.3 и ниже.&lt;/p&gt;
&lt;p&gt;Опять же modernizr хорошо помогает здесь и даже более эффективно чем с img. Если мы поменяем значение для &lt;code&gt;background-image&lt;/code&gt; на поддерживаемый формат то буден сделан только один http запрос вместо двух в предыдущем случае. Модернизер добавляет класс в html - &lt;code&gt;no-svg&lt;/code&gt; если браузер не поддерживает формат, и тогда мы можем сделать:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.main-header {
  background: url(logo.svg) no-repeat top left;
  background-size: contain;
}

.no-svg .main-header {
  background-image: url(logo.png);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Другой умный прием использования svg фоновых картинок заключается в том чтобы использовать их совместно с множественным фоном. SVG и фоновые картинки имеют одинаковую поддержку браузеров так что если браузер понимает множественный бекграунд то он понимает и svg, поэтому:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;body {
  background: url(fallback.png);
  background-image: url(image.svg), none;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###Проблема с &lt;img&gt; и с фоновыми картинками&lt;/p&gt;
&lt;p&gt;В том что вы не получаете контроля над содержимым SVG по сравнению с следующими двумя способами.&lt;/p&gt;
&lt;p&gt;##Инлайновый svg&lt;/p&gt;
&lt;p&gt;Помните способ получить код svg который мы встречали когда сохраняли svg из иллюстратора? Этот же самый код можно получить просто открыв svg файл текстовым редактором. Так вот можно взять этот код, вставить прямо в html и мы получим ту же самую картинку как если бы вставили элементом img.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;body&amp;gt;

   &amp;lt;!-- paste in SVG code, image shows up!  --&amp;gt;

&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Плюс здесь в том что картинка уже находится прямо в документе и не требует никаких http запросов. Другими словами плюсы в этом такие же как при использовании &lt;a href=&#34;http://css-tricks.com/data-uris/&#34;&gt;Data URI&lt;/a&gt;. И недостатки тоже те же самые. Потенциально раздутый код, здоровая куча хлама прямо в документе который вы редактируете плюс невозможность кеширования.&lt;/p&gt;
&lt;p&gt;Если вы пишете на каком нибудь серверном языке то вы можете добиться чистоты как то так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php include(&amp;quot;kiwi.svg&amp;quot;); ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###Оптимизация&lt;/p&gt;
&lt;p&gt;Наверно вас это не сильно удивит но svg который делает иллюстратор не самый идеальный с точки зрения оптимизации. Поджать можно при помощи &lt;a href=&#34;http://petercollingridge.appspot.com/svg_optimiser&#34;&gt;SVG Optimiser&lt;/a&gt;. Загружаете старый выгружаете новый. В этом &lt;a href=&#34;http://www.youtube.com/watch?v=iVzW3XuOm7E&amp;amp;feature=youtu.be&#34;&gt;видео&lt;/a&gt; показываеться что можно даже удалить переносы строк после такой оптимизации.&lt;/p&gt;
&lt;p&gt;Если вы реально круты вот вам &lt;a href=&#34;https://github.com/svg/svgo&#34;&gt;инструмент&lt;/a&gt; для Нода.&lt;/p&gt;
&lt;p&gt;И теперь можно контролировать картинку стилями!&lt;/p&gt;
&lt;p&gt;Нетрудно заметить что svg выглядит очень похоже на html, это потому что по сути xml документы. Наша конкретная картинка состоит из двух тегов, &lt;code&gt;&amp;lt;ellipse&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;. Ничего нам не мешает присвоить элементам классы точно также как мы делаем в html.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;svg ...&amp;gt;
  &amp;lt;ellipse class=&amp;quot;ground&amp;quot; .../&amp;gt;
  &amp;lt;path class=&amp;quot;kiwi&amp;quot; .../&amp;gt;
&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь мы можем стайлить эти элементы специальным svg css. Эти стили не обязательно должны быть внутри svg, можно даже их выносить в наши обычные стили. Обратите внимание что элементы svg имеют свои специфические css свойства. К примеру вместо &lt;code&gt;background-color&lt;/code&gt; надо использовать &lt;code&gt;fill&lt;/code&gt;. Обычные штуки типа ховера работают.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.kiwi {
  fill: #94d31b; 
}
.kiwi:hover {
  fill: #ace63c; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Что совсем круто так это фильтры в svg. Например размытие. Сначала надо вписать фильтр в svg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;svg ...&amp;gt;
  ...
  &amp;lt;filter id=&amp;quot;pictureFilter&amp;quot; &amp;gt;
    &amp;lt;feGaussianBlur stdDeviation=&amp;quot;5&amp;quot; /&amp;gt;
  &amp;lt;/filter&amp;gt; 
&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Потом это используется в стилях так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.ground:hover {
    filter: url(#pictureFilter);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;jsbin-embed&#34; href=&#34;http://jsbin.com/qeyuju/1/embed?output&#34;&gt;JS Bin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;###Поддержка&lt;/p&gt;
&lt;p&gt;У встроенный svg свой &lt;a href=&#34;http://caniuse.com/#feat=svg-html5&#34;&gt;набор поддерживаемых браузеров&lt;/a&gt;, но, опять же, проблемы с ИЕ8 и андроидом 2.3.&lt;/p&gt;
&lt;p&gt;Один способ реализовать совместимость:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;svg&amp;gt; ... &amp;lt;/svg&amp;gt;
&amp;lt;div class=&amp;quot;fallback&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Дальше при помощи Модернизера:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.fallback { 
  display: none;

}
.no-svg .fallback { 
  background-image: url(logo.png); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##SVG как &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Если видеть в html кучу хлама вам не по душе можно залинковать svg файл сохраняя возможность работать с деревом элементов:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;object type=&amp;quot;image/svg+xml&amp;quot; data=&amp;quot;kiwi.svg&amp;quot; class=&amp;quot;logo&amp;quot;&amp;gt;
  Kiwi Logo &amp;lt;!-- fallback image in CSS --&amp;gt;
&amp;lt;/object&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для старья опять Модернизер:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.no-svg .logo {
  width: 200px;
  height: 164px;
  background-image: url(kiwi.png);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В данном случае мы получаем кеширование и наилучшую поддержку браузерами чем в любом другом варианте, но для того чтобы работали стили придется включать стили внутрь svg файла. Ни внешние стили ни стили внутри &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; работать не будут.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;&amp;lt;svg ...&amp;gt;
  &amp;lt;style&amp;gt;
    /* SVG specific fancy CSS styling here */
  &amp;lt;/style&amp;gt;
  ...
&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###Внешние стили для &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Есть способ для указания внешних стилей что есть неплохо для кеширования. Это работает только для &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; содержащими svg файл, по крайней мере мои тесты показали так. Нужно в ваш svg файл поместить вот это перед открытием svg тега.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;?xml-stylesheet type=&amp;quot;text/css&amp;quot; href=&amp;quot;svg.css&amp;quot; ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если вы это вставите в ваш html то страница не срендерится, если это будет в svg но svg вставляется как &lt;img&gt; или как фоновая картинка, страница отрисуется, svg тоже срендерится но стили эти работать не будут.&lt;/p&gt;
&lt;p&gt;##Data URI&lt;/p&gt;
&lt;p&gt;Еще один способ сжать максимально это сконвертировать svg в data uri. Можно это сделать &lt;a href=&#34;http://www.mobilefish.com/services/base64/base64.php&#34;&gt;специальным сервисом&lt;/a&gt;. Кидаете туда содержимое вашего svg файла и получаете вот такой вот мусор. Не забудьте удалить переносы строк.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.css-tricks.com/wp-content/uploads/2013/03/base64-data.png&#34; alt=&#34;svg data uri&#34; title=&#34;figure&#34;&gt;&lt;/p&gt;
&lt;p&gt;Потом это можно вставлять во все варианты о которых мы говорили кроме конечно инлайновый svg, это просто не имеет смысла в данном случае. Этот код должен быть на месте &lt;code&gt;[data]&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;###Картинка&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;img src=&amp;quot;data:image/svg+xml;base64,[data]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###CSS&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;logo {
  background: url(data:image/svg+xml;base64,[data]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###Object&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;object type=&amp;quot;image/svg+xml&amp;quot; data=&amp;quot;data:image/svg+xml;base64,[data]&amp;quot;&amp;gt;
  fallback
&amp;lt;/object&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И - если у вас были вложенные стили &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;  в вашем svg перед тем как вы конвертировали это по прежнему будет работать в случае использования как &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;##Полезные инструменты&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;a href=&#34;https://github.com/filamentgroup/grunticon&#34;&gt;grunticon&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Берет папку с svg/png файлами (иконки сделанные в илюстраторе или типа того), и выводит ее в трех форматах: svg data uri, png data uri и таблицу стилей для совместимости с сылками на обычные картинки, которые тоже генерируются автоматически и выкладываются в отдельную папку.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;strong&gt;&lt;a href=&#34;https://github.com/jkphl/iconizr&#34;&gt;iconizr&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Консольный инструмент (PHP) для конвертирования svg картинок в набор иконок (svg &amp;amp; png, отдельные иконки и / или спрайты) с поддержкой оптимизации и выходного формата в sass.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##По теме&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;David Bushell: &lt;a href=&#34;http://dbushell.com/2013/02/04/a-primer-to-front-end-svg-hacking/&#34;&gt;A Primer to Front-end SVG Hacking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;David Bushell: &lt;a href=&#34;http://coding.smashingmagazine.com/2012/01/16/resolution-independence-with-svg/&#34;&gt;Resolution Independence With SVG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/SVG&#34;&gt;MDN on SVG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Browser support for &lt;a href=&#34;http://caniuse.com/#search=svg&#34;&gt;a variety of different SVG related things&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Peter Gasston: &lt;a href=&#34;http://www.broken-links.com/2012/08/14/better-svg-sprites-with-fragment-identifiers/&#34;&gt;Better SVG Sprites With Fragment Identifiers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;simuari: &lt;a href=&#34;http://simurai.com/post/20251013889/svg-stacks&#34;&gt;SVG Stacks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svgjs.com/&#34;&gt;SVG.js&lt;/a&gt; - &amp;quot;A lightweight library for manipulating and animating SVG.&amp;quot;&lt;/li&gt;
&lt;li&gt;Emmet has an &lt;a href=&#34;http://docs.emmet.io/actions/base64/&#34;&gt;awesome way&lt;/a&gt; to get a data URI from an SVG right from your code editor.&lt;/li&gt;
&lt;li&gt;Compass &lt;a href=&#34;http://compass-style.org/reference/compass/helpers/inline-data/&#34;&gt;has a helper&lt;/a&gt; for data URIs too.&lt;/li&gt;
&lt;li&gt;Adobe: &lt;a href=&#34;http://blogs.adobe.com/webplatform/2013/01/08/svg-styling/&#34;&gt;Styling SVG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Andrew J. Baker: &lt;a href=&#34;http://buildnewgames.com/taming-the-svg-beast/&#34;&gt;Taming the SVG Beast&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Illustrator alternatives: &lt;a href=&#34;http://inkscape.org/&#34;&gt;Inkscape&lt;/a&gt;, &lt;a href=&#34;http://www.bohemiancoding.com/sketch/#4&#34;&gt;Sketch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Krister Kari: &lt;a href=&#34;http://kristerkari.github.com/adventures-in-webkit-land/blog/2013/03/08/dealing-with-svg-images-in-mobile-browsers/&#34;&gt;Dealing with SVG images in mobile browsers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

				</description>
				<dc:creator><![CDATA[rooc]]></dc:creator>
				<pubDate>
					Wed Jun 18 2014 03:00:00 GMT+0300 (EEST)
				</pubDate>
			</item>
			
		
			<item>
				<title>Странный button</title>
				<link>rooc.githubblog/buttons.html</link>
				<description>
					&lt;p&gt;Речь пойдет о верстке кнопок. Когда верстаются кнопки обычно делается несколько модификаций, в том числе модификаций размера. Меня сейчас интересуют изменения отступов при изменении размера шрифта кнопки. Так это делается в бутстрапе:&lt;!-- more --&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.btn {
    ...
    padding: 6px 12px;
}

.btn-lg {
    ...
    padding: 10px 16px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Мне казалось логично было бы сделать оступы либо высоту кнопки  в &lt;code&gt;em&lt;/code&gt; поскольку отступы должны зависеть от размера шрифта.&lt;/p&gt;
&lt;p&gt;Помимо этого нужно чтобы стили не зависели от html элемента к которому они применяются, то есть они должны работать одинаково на &lt;code&gt;a, button, div&lt;/code&gt;. Когда я начал экспериментировать то увидел такую картину:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;jsbin-embed&#34; href=&#34;http://jsbin.com/guwoc/19/embed?output&#34;&gt;JS Bin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Справа элемент &lt;code&gt;button&lt;/code&gt;, слева &lt;code&gt;a&lt;/code&gt;. Оказывается элемент &lt;code&gt;button&lt;/code&gt; сам выравнивает текст вертикально. Может это не новость но я не знал.&lt;/p&gt;
&lt;p&gt;Еще одна интересная особенность &lt;code&gt;button&lt;/code&gt; - элемент включает в свою высоту бордер и отступы, то есть ведет себя как будто для него работает &lt;code&gt;box-sizing: border-box;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;jsbin-embed&#34; href=&#34;http://jsbin.com/guwoc/18/embed?output&#34;&gt;JS Bin&lt;/a&gt;
Попробуйте расскомментировать строку с &lt;code&gt;box-sizing&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Финальный вариант получился такой:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;jsbin-embed&#34; href=&#34;http://jsbin.com/guwoc/16/embed?output&#34;&gt;JS Bin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;В нем есть свои минусы, например кнопка не допускает двухстрочной подписи. Можно сделать отступы сверху-снизу в &lt;code&gt;em&lt;/code&gt;, просто бывает так что при определенных шрифтах для точного центрирования надо делать разными отсуп снизу и сверху.&lt;/p&gt;

				</description>
				<dc:creator><![CDATA[rooc]]></dc:creator>
				<pubDate>
					Wed Jun 11 2014 03:00:00 GMT+0300 (EEST)
				</pubDate>
			</item>
			
		
			<item>
				<title>OOCSS. Утилиты</title>
				<link>rooc.githubblog/oocss-utils.html</link>
				<description>
					&lt;p&gt;Обьектно-ориентированный CSS, он же яндексовый метод БЕМ, он же SMACSS, это находка, благодаря которой в верстку пришел порядок. Ну почти. Особенно это очевидно на больших проектах которые переделываются не один раз. Но об этом уже много говорилось, добавить уже нечего. Я хочу рассказать о некоторых проблемах при работе c этой идеологией.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Мне казалось что в идеале CSS должен содержать только дефолтные стили для всех тегов плюс набор модулей. То есть не должно быть никаких случайных стилей добавленных в конец файла, все должно быть четко структурировано по модулям. Например такого быть не должно:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.tutorials div.tutorialIndexImg {
    text-align: center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Мало того что непонятно для чего нужная каскадность да еще и тривильное выравнивание по центру.&lt;/p&gt;

				</description>
				<dc:creator><![CDATA[rooc]]></dc:creator>
				<pubDate>
					Tue Feb 18 2014 02:00:00 GMT+0200 (EET)
				</pubDate>
			</item>
			
		
			<item>
				<title>HarpJs</title>
				<link>rooc.githubblog/harpjs.html</link>
				<description>
					&lt;p&gt;Статические генераторы стали модной темой, их появилось &lt;a href=&#34;http://staticsitegenerators.net/&#34;&gt;много&lt;/a&gt;. Раз в месяц мне попадается статья типа - &lt;a href=&#34;http://joefleming.net/posts/wordpress-out-docpad-in/&#34;&gt;Как я перешел от вордпресса к статике&lt;/a&gt;.&lt;!-- more --&gt;&lt;/p&gt;
&lt;p&gt;Я начал использовать статические генераторы просто как инструмент для верстки, на этапе превращения дизайнерского макета в статические html, css, js. Эта верстка потом идет дальше к программерам или еще куда. Это удобно потому что у тебя в распоряжении сразу приятные мелочи типа препроцессинг стилей, инклуды. Тот же CoffeeScript например, если вы им пользуетесь. Сначала я пробовал пользоваться для этих целей грантом, но стало не хватать возможностей, типа метаданные для страниц. Хотя это можно каким то боком сделать, скажем, с помощью Jade, но это не так удобно как это бывает в статических генераторах. Возможно я не прав и все это можно сделать при помощи &lt;a href=&#34;http://gruntjs.com/&#34;&gt;Grunt&lt;/a&gt; или &lt;a href=&#34;http://gulpjs.com/&#34;&gt;Gulp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Первым генератором которым я пользовался более-менее продолжительно был Docpad. Очень неплохой генератор, супернавороченный, с тонной плагинов и хорошим сообществом. В какой то момент у меня появилась бага, которую я не мог разрешить. Она была очень надоедливая, и решил посмотреть другие генераторы. Ничего плохого в адресс докпада сказать не хочу, он &lt;a href=&#34;http://emmet.io/blog/docpad/&#34;&gt;хороший&lt;/a&gt;.&lt;/p&gt;

				</description>
				<dc:creator><![CDATA[rooc]]></dc:creator>
				<pubDate>
					Tue Jan 21 2014 02:00:00 GMT+0200 (EET)
				</pubDate>
			</item>
			
		
	</channel>
</rss>