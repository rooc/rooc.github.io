<!DOCTYPE HTML>
<html lang="ru">
	
	<head>
	<meta charset="utf-8">
	
		
	
	
	
	<title>Rooc :: Блог :: Модульный CSS и селекторы атрибутов</title>
	<meta name="description" content="Модульный CSS на основе атрибутов">
	<meta name="keywords" content="css, modules, attributes, модульный css, атрибуты">
	<meta name="author" content="rooc">
	<meta name="viewport" content="width=device-width">
	<link rel="icon" href="/assets/img/favicon.png">
	<link href='http://fonts.googleapis.com/css?family=PT+Serif:400italic&subset=latin,cyrillic' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" href="/assets/css/styles.css">
</head>

	<body>
		<div class="l-header">
	<div class="l-sitewidth">
		<a href="/" class="logo">Rooc</a>
		<nav>
	<ul class="nav">
		
		<li class="nav-item">
			<a href="/">Блог</a>
		</li>
		
		<li class="nav-item">
			<a href="/folio/">Портфолио</a>
		</li>
		
		<li class="nav-item">
			<a href="/archive/">Архив</a>
		</li>
		
		<li class="nav-item">
			<a href="/links/">Полезное</a>
		</li>
		
	</ul>
</nav>
	</div>
</div>
		<div class="l-content">
			<div class="l-sitewidth">
				<div class="l-article">
					<div class="l-space">
						<div class="social">
	<a href="https://twitter.com/share" class="social-link" data-via="rooczebra" data-count="none"><i class="ifont--twitter"></i></a>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.async=true;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
	<!-- <a href="https://twitter.com/share" class="social-link" data-via="rooczebra" data-count="none"><i class="icon-font--facebookSquared"></i></a> -->
</div>
						<h1>Модульный CSS и селекторы атрибутов</h1>
						<div class="meta">
	<span class="meta-date">
		Декабрь 13, 2014
	</span>
	&nbsp;||&nbsp;
	<span class="meta-tags">
		
			
			<a href="/tags/css.html">css</a>
		
			, 
			<a href="/tags/oocss.html">oocss</a>
		
			, 
			<a href="/tags/translation.html">translation</a>
		
	</span>
	
		&nbsp;||&nbsp;
		<a class="meta-original" href="http://glenmaddern.com/articles/introducing-am-css" target="_blank">Introducing AM - Attribute Modules for CSS</a>
	
	&nbsp;||&nbsp;
	<span class="meta-comments">
		<a href="#disqus_thread" data-disqus-identifier="attr-modules-disqus">комментарии</a>
	</span>
</div>
						<p>Несколько месяцев назад мне попалась <a href="http://csswizardry.com/2014/05/grouping-related-classes-in-your-markup/">статья Гарри Робертса</a> в которой он представил интересную концепцию работы с сопряженными классами в CSS. В этой статье он предложил использовать символы <code>[ ]</code> для группировки классов для того чтобы быстро распознать их смысл при беглом просмотре. Он приводит данный пример, утверждая что в таком виде декларация стилей становится более &quot;распознавабельной&quot;:</p>
<!-- more -->
<pre><code class="language-html">&lt;div class=&quot;[ foo  foo--bar ]  [ baz  baz--foo ]&quot;&gt;
</code></pre>
<p>Признаюсь, сначала я принял такой подход в штыки. Идея имен классов с именами <code>[ ]</code> которым к тому же не соотвествуют никакие стили, да еще повторяются внутри одного атрибута, которые имеют смысл только для человека и не для браузера, выглядит очень странной. Я собственно и по прежнему думаю также, но тем не менее, это заставило меня задуматься о верстке и семантике поглубже, поэтому - спасибо Гарри!</p>
<p>Пока я думал об этом я нашел что разные люди предлагали похожие подходы, например использовать <code>/</code> (<a href="http://beneverard.co.uk/blog/using-slashes-within-the-html-class-attribute/">Ben Everard</a>), или <code>|</code> (<a href="https://twitter.com/sn0lan/status/439384690680942592/">Steven Nolan</a>), но все эти способы оставляют ощущение искусственности.</p>
<blockquote>
<p>Как так вышло что у вас так много классов что вам нужны новые классы чтобы сделать их читабельными?</p>
</blockquote>
<p>Короче говоря это сумашествие. Хорошо читабельный HTML это конечно достойная цель, но такого рода приемы говорят что что то у нас фундаментально пошло не так с наименованием стилей.</p>
<h2>Больше классов против меньше классов</h2><p>Странная штука, но несмотря на то что обилие классов в разметке кажется мне не нормальным, люди типа Гарри чертовски убедительны. Исходя из принципов OOCSS или <a href="http://csswizardry.com/2012/04/the-single-responsibility-principle-applied-to-css/">Single Responsibility Principle</a>, а также из моего личного опыта работы со сложными сайтами, я могу сказать что есть определенная ценность в &quot;дроблении&quot;  стилей, но тем не менее только недавно я нашел способ который меня удовлетворил.</p>
<p>Перед этим я адаптировал версию методологии БЭМ которая делает акцент на изоляции а не на повторном использовании - каждый новый блок по умолчанию не наследует никаких стилей, позволяя компоненту разрабатываться изолированно и избежать риска испортить что либо в другом месте сайта.
Но недостаток такого подохода в том что в итоге вы обнаруживаете что у вас 10 различных стилей для ссылок, 12 оттенков голубого, 18 слегка отличающихся стилей кнопок. Николь Саливан, создатель OOCS, в своей фантастической <a href="https://www.youtube.com/watch?v=0NDyopLKE1w">презентации</a> в прошлом году в Мельбурне рассказала как часто такое случается и как это исправлять.</p>
<p>Для меня выходом, который меня устраивал, было использовать возможности препроцессоров для того чтобы совместить атомарность БЭМ и согласованность OOCSS. К примеру, вместо такого:</p>
<pre><code class="language-html">&lt;a class=&#39;btn large rounded&#39;&gt;
</code></pre>
<pre><code class="language-css">.btn { /* button styles */ }
.large { /* global large-type modifier */ }
.rounded { /* global rounded-border modifier */ }
</code></pre>
<p>имеем такое:</p>
<pre><code class="language-html">&lt;a class=&#39;btn btn--large btn--rounded&#39;&gt;
</code></pre>
<pre><code class="language-scss">.btn { /* button styles */ }
.btn--large {
  @extend %large-type;
}
.btn--rounded {
  @extend %rounded-borders;
}
</code></pre>
<p>В итоге я пришел к тому что у меня была кучка файлов типа <code>_typography.scss</code>, <code>_brand.scss</code>, которые позволяли мне более менее поддерживать фрагментацию и в то же время изоляцию отдельных компонентов. И все было ОК, до поры до времени.</p>
<h2>Модификаторы: как М ломает БЭМ</h2><p>Если вы изучаете вопрос наименования классов в CSS и поддержки стилей, вы неизбежно натолкнетесь на отличную статью Николаса Галахера  <a href="http://nicolasgallagher.com/about-html-semantics-front-end-architecture/">&quot;About HTML semantics and front-end architecture&quot;</a>. Одна часть особенно привлекла мое внимание, то что он называет шаблоном &quot;один класс&quot; против &quot;множественные классы&quot;. В вашей разметке потенциально может быть два таких варианта:</p>
<pre><code class="language-html">&lt;a class=&#39;btn--large&#39;&gt; &lt;!-- Single class --&gt;
&lt;a class=&#39;btn btn--large&#39;&gt; &lt;!-- Multi class --&gt;
</code></pre>
<p>Это соответствует двум подходам в CSS:</p>
<pre><code class="language-css">/* Single class */
.btn, .btn--large { /* base button styles */ }
.btn--large { /* large button styles */ }

/* Multi class */
.btn { /* base button styles */ }
.btn--large { /* large button styles */ }
</code></pre>
<p>Разница тут в том самостоятелен ли класс <code>btn--large</code> или он требует присутствия родительского класса <code>btn</code>. В шаблоне &quot;один класс&quot; он самостоятелен, это выглядит проще и удобнее, и страхует от случая когда вы забыли вписать второй класс. Плюс с функционалом препроцессоров <code>@extend</code> это выглядит совсем просто. Но, такой подход подвержен серьезному недостатку.</p>
<p>##Контекстные модификации</p>
<p>Представим что все кнопки на сайте имеют какой то фоновый цвет, за исключением тех которые находятся в панели навигации в шапке сайта. В случае паттерна &quot;множественные классы&quot; вы добираетесь до кнопок в навигации так:</p>
<pre><code class="language-css">header &gt; nav &gt; .btn { background: none; }
</code></pre>
<p>В случае если вы используете паттерн с одним классом вы не знаете точно какой вариант кнопки вам надо перекрыть поэтому мы вынуждены поступать так:</p>
<pre><code class="language-scss">header &gt; nav {
  .btn, .btn--large, .btn--rounded { background: none; }
}
</code></pre>
<p>Как можно догадаться это не идеально, каждый раз когда вы добавляете новый модификатор кнопки вам надо не забыть и вписать сюда этот класс. Это все не очень здраво, поэтому многие считают что надо вернуться к варианту множественных классов. (<a href="http://nicolasgallagher.com/about-html-semantics-front-end-architecture/">Nicholas Gallagher</a>, <a href="http://bensmithett.com/bem-modifiers-multiple-classes-vs-extend/">Ben Smithett</a>). Встречал и другие альтернативные варианты, метод <a href="http://viget.com/extend/bem-multiple-modifiers-and-experimenting-with-attribute-selectors">Томми Маршала</a> или <a href="http://benfrain.com/multiple-classes-ui-component-variations-wrong/">Бена Фрейна</a>, которые используют селектор атрибута <code>^=</code> которым можно проверить начинается ли атрибут определенной строкой, например:</p>
<pre><code class="language-html">&lt;a class=&#39;btn--large&#39;&gt;
</code></pre>
<pre><code class="language-css">[class^=&#39;btn&#39;] { /* базовые стили кнопок */ }
.btn--large { /* модификатор для большой кнопки */ }
header &gt; nav &gt; [class^=&#39;btn&#39;] { /* Перекрывает все кнопки */ }
</code></pre>
<p>Таким способом легко перекрыть стили шаблона &quot;один класс&quot;, но все таки это слишком хрупкий способ чтобы рассматривать его серьезной альтернативой. Если к примеру у вас в стилях каким то образом первый класс оказался не <code>btn</code>  то все ломается. </p>
<p>Я конечно ценю изобретательность такого подхода, но это тупик. Это как раз то место где я застрял, до тех пор пока мне не пришло в голову кое что.</p>
<h1>##Какого </h1><p>[class^=&#39;btn&#39;] { /<em> base button styles </em>/ }
.btn--large { /<em> large button styles </em>/ }
header &gt; nav &gt; [class^=&#39;btn&#39;] { /<em> Overrides for all buttons </em>/ }</p>
<pre><code>
Это конечно удобный вариант для метода &quot;один класс&quot; но все таки это слишком хрупкая конструкция чтобы быть серьезной альтернативой. Если какой то другой класс окажется перед `btn--large` то вся конструкция летит к чертям. Плюс ко всему нет ясного способа как в этом случае иметь дело с модификатором модификатора типа `btn--large--rounded`.

Я ценю изобретательность этого метода но это тупик. И это то место где я застрял до момента когда кое что пришло мне в голову.

##А чего мы вообще приклеились &lt;br&gt; к атрибуту class?

Пардон за мою тупость но кто нибудь может доказать мне что `class` это единственный атрибут который мы можем использовать для селекторов стилей? Вот что говорит [спецификация HTML](http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#classes):

&gt; **3.2.5.7 The class attribute**   
&gt;
&gt; Атрибут, если определен, должен иметь значение, состоящее из группы разделенных пробелом
&gt; имен представляющих различные классы к которым принадлежит элемент.  
&gt;
&gt; Нет никаких ограничений какие имена может использовать автор но рекомендуется использовать 
&gt; имена которые описывают природу или значение содержимого а не желаемый внешний вид 
&gt; содержимого.

Ну да, это чудесно что мы используем атрибут класс для описания &quot;природы содержимого&quot;, но все таки ощущение такое что мы хотим от него больше чем он может дать. Этот многострадальный атрибут содержит все, начиная от громоздких БЭМ имен типа `primary-nav__sub-nav--current` или вспомогательных классов типа `u-textTruncate` или `left clearfix`, до джаваскрипт указателей `js-whatevs`, в итоге мы тратим кучу времени на придумывание имен которые не конфликтуют один с другим и тем не менее читабельны.

С этим можно справится при помощи дисциплины и соглашений и с помощью разных техник, но правда в том что мы работаем в глобальном пространстве имен, и никакие соглашения не могут это изменить. А это как раз то что делает АМ особым.

Но прежде чем мы поговорим об этом нам нужно освежить одну не очень известную фишку в CSS.

##Магический селектор ~=

Оказывается что браузеры аж с времен IE7 поддерживают мощнецкое правило называемое **селектор атрибутов разделенных пробелом**, описанную [тут на CSS Tricks](http://css-tricks.com/attribute-selectors/#rel-space). Он цепляет произвольные значения атрибутов, разделенных пробеламы, так как будто это и есть классы. К примеры следующие две строки идентичны:

```css
.dat-class { /* dem styles */ };
[class~=&#39;dat-class&#39;] { /* dem styles */ };
</code></pre><p>Точно также как для <code>&lt;div class=&quot;a b c &quot;&gt;</code> не имеет значения в каком порядке стоят a, b или с, или что еще есть помимо них, также это не важно для селектора <code>~=</code>. Но этот селектор не ограничен атрибутом class, он работает точно также с любым другим атрибутом. И это ключевой момент в новом подходе.</p>
<p>&quot;Модули атрибутов&quot;, или АМ, это по сути определение пространства имен в которых живут стили. Начнем с простого примера, колонки:</p>
<pre><code class="language-html">&lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;column-12&quot;&gt;Full&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;column-4&quot;&gt;Thirds&lt;/div&gt;
    &lt;div class=&quot;column-4&quot;&gt;Thirds&lt;/div&gt;
    &lt;div class=&quot;column-4&quot;&gt;Thirds&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">.row { /* max-width, clearfixes */ }
.column-1 { /* 1/12th width, floated */ }
.column-2 { /* 1/6th width, floated */ }
.column-3 { /* 1/4th width, floated */ }
.column-4 { /* 1/3rd width, floated */ }
.column-5 { /* 5/12th width, floated */ }
/* etc */
.column-12 { /* 100% width, floated */ }
</code></pre>
<p>Теперь построим это же самое на АМ. У нас есть два модуля, строки(rows) и колонки(columns). У строки нет вариаций, у колонок их 12.</p>
<pre><code class="language-html">&lt;div am-Row&gt;
    &lt;div am-Column=&quot;12&quot;&gt;Full&lt;/div&gt;
&lt;/div&gt;
&lt;div am-Row&gt;
    &lt;div am-Column=&quot;4&quot;&gt;Thirds&lt;/div&gt;
    &lt;div am-Column=&quot;4&quot;&gt;Thirds&lt;/div&gt;
    &lt;div am-Column=&quot;4&quot;&gt;Thirds&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">[am-Row] { /* max-width, clearfixes */ }
[am-Column~=&quot;1&quot;] { /* 1/12th width, floated */ }
[am-Column~=&quot;2&quot;] { /* 1/6th width, floated */ }
[am-Column~=&quot;3&quot;] { /* 1/4th width, floated */ }
[am-Column~=&quot;4&quot;] { /* 1/3rd width, floated */ }
[am-Column~=&quot;5&quot;] { /* 5/12th width, floated */ }
/* etc */
[am-Column~=&quot;12&quot;] { /* 100% width, floated */ }
</code></pre>
<p>Первое что вы наверно заметили это префикс <code>am-</code>. Это важно чтобы не создать конфликтов с другими существующими атрибутами. Конечно можно использовать любой префикс, я пробовал <code>ui-</code>, <code>css-</code> и другие, но оставился на <code>am-</code> для данных примеров. Если валидность HTML критична для вас то можно использовать атрибут в виде <code>data-</code>, смысл тот же.</p>
<p>Второе что вы наверно заметили это значения атрибутов типа <code>1</code>, <code>2</code>. Если бы это были имена классов это было бы ужасно, они слишком общеупотребительные и шансы конфликтов велики. Но поскольку мы определили свое собственное пространство имен, мы можем использовать максимально короткие имена.</p>
<p>##Гибкость значений атрибутов</p>
<p>На данный момент плюсы от нового способа минорные. Но поскольку каждый модуль задает свое пространство имен, давайте попробуем немного другую схему значений:</p>
<pre><code class="language-html">&lt;div am-Row&gt;
    &lt;div am-Column&gt;Full&lt;/div&gt;
&lt;/div&gt;
&lt;div am-Row&gt;
    &lt;div am-Column=&quot;1/3&quot;&gt;Thirds&lt;/div&gt;
    &lt;div am-Column=&quot;1/3&quot;&gt;Thirds&lt;/div&gt;
    &lt;div am-Column=&quot;1/3&quot;&gt;Thirds&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">[am-Row] { /* max-width, clearfixes */ }
[am-Column] { /* 100% width, floated */ }
[am-Column~=&quot;1/12&quot;] { /* 1/12th width */ }
[am-Column~=&quot;1/6&quot;] { /* 1/6th width */ }
[am-Column~=&quot;1/4&quot;] { /* 1/4th width */ }
[am-Column~=&quot;1/3&quot;] { /* 1/3rd width */ }
[am-Column~=&quot;5/12&quot;] { /* 5/12ths width */ }
/* etc */
</code></pre>
<p>Теперь мы можем легко использовать имена для наших конкретных нужд, ширина колонки 1/3 сразу же говорит что это значит, тогда как например 4 предполагает что мы помним что используем 12 колоночную сетку. Атрибут <code>column</code> без значения например означает колонку 100% ширины, и как бонус мы можем в атрибут без значения перенести всю повторяемую логику,  (<code>float: left</code>) например.</p>
<p>##Определение стилей для атрибута и для его значений</p>
<p>Это главная прелесть этого подхода. Наличие атрибута, например <code>am-Button</code>, само по себе может быть застилено. Конкретное значение атрибута модифицирует эти базовые стили.</p>
<p>В примере с сеткой выше мы делаем именно это: разметка <code>am-Column = &quot;1/3&quot;</code> подпадает сразу под оба селектора, и <code>[am-Column]</code>  и <code>[am-Column~=&quot;1/3&quot;]</code> , поэтому результат это базовые стили плюс вариации. Это избавляет от копирования классов или использования функционала <code>@extend</code>.</p>
<h2>&quot;Без классовый&quot; подход к БЕМ модификаторам</h2><p>Вернемся к спору между шаблоном &quot;один класс&quot; и &quot;множественные классы&quot;. АМ предлагает способ без классов. Ну к примеру, для случая четырех вариантов кнопок разметка выглядит так:</p>
<pre><code class="language-html">&lt;a am-Button&gt;Normal button&lt;/a&gt;
&lt;a am-Button=&#39;large&#39;&gt;Large button&lt;/a&gt;
&lt;a am-Button=&#39;rounded&#39;&gt;Rounded button&lt;/a&gt;
&lt;a am-Button=&#39;large rounded&#39;&gt;Large rounded button&lt;/a&gt;
</code></pre>
<pre><code class="language-css">[am-Button] { /* base button styles */ }
[am-Button~=&quot;large&quot;] { /* large button styles */ }
[am-Button~=&quot;rounded&quot;] { /* round button styles */ }
</code></pre>
<p>При помощи атрибута <code>am-Button</code>, мы можем разделить стили которые общие для всех кнопок и стили которые делают кнопку большой, или стили для скругленной кнопки. Мы можем не только спокойно комбинировать вариации кнопок (<code>am-Button = &quot;large rounded&quot;</code>), но мы можем выбирать сам атрибут для любых контекстных модификаций:</p>
<pre><code class="language-css">header &gt; nav &gt; [am-Button] { background: none; }
</code></pre>
<p>Не важно какой вариант кнопки у нас используется, или как много вариантов мы решим создать, мы можем выбрать все кнопки одним селектором <code>[am-Button]</code>, поэтому мы можем быть уверены что модификации будут валидными.</p>
<h2>AMCSS проект</h2><p>Я (<a href="http://glenmaddern.com/">Glen Maddern</a>), <a href="http://germanforblack.com/">Ben Schwarz</a> и <a href="http://bensmithett.com/">Ben Smithett</a> начали работу над спецификацией АМ. Если вы хотите узнать больше как эта техника расширяет блоки, элементы, точки перехода (breakpoints) и больше, поднимайте пожалуйста свой <a href="https://github.com/amcss/attribute-module-specification/issues">вопрос</a>.</p>
<p>Также мы сделали сайт с документацией, с разными примерами как использовать АМ, <a href="http://amcss.github.io/">amcss.github.io</a>. Если вам интересно внести свой вклад, сделать примеры или вы хотите показать нам свои варианты АМ библиотек, пишите нам на <a href="https://github.com/amcss/amcss.github.io">Гитхаб</a>.</p>
					</div>
					
						<div class="l-space l-box l-line">
	<div id="disqus_thread"></div>
</div>

<script>
	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
	var disqus_shortname = 'roocblog';
	var disqus_identifier = 'attr-modules-disqus';

	/* * * DON'T EDIT BELOW THIS LINE * * */
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>

<noscript>
	Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>

<a href="http://disqus.com" class="dsq-brlink">
	comments powered by 
	<span class="logo-disqus">Disqus</span>
</a>
					
				</div>
				<div class="l-sidebar">
					<div class="l-space-l l-box l-line" rel="recent">
	<h5>Недавно</h5>
	<ul class="list--simple t-size-s">
		
		
		
			
		
			
				<li><a href="/blog/using-svg.html" class="t-link--sidebar">Основы работы с SVG</a></li>
			
		
			
				<li><a href="/blog/buttons.html" class="t-link--sidebar">Странный button</a></li>
			
		
			
				<li><a href="/blog/oocss-utils.html" class="t-link--sidebar">OOCSS. Утилиты</a></li>
			
		
			
				<li><a href="/blog/harpjs.html" class="t-link--sidebar">HarpJs</a></li>
			
		
			
				<li><a href="/blog/todos.html" class="t-link--sidebar">Планировщики</a></li>
			
		
	</ul>
</div>

<div class="l-space-l l-box l-line" rel="tags">
	<h5>Теги</h5>
	<ul class="list--tags t-size-s">
		
		
			
				
					
						
					
				
					
						
					
				
					
						
					
				
			
		
			
				
					
				
					
						
					
				
					
				
			
		
			
				
					
				
					
						
					
				
			
		
			
				
					
				
			
		
			
				
					
						
					
				
			
		
			
				
					
				
			
		
			
				
					
				
			
		
			
				
					
				
					
						
					
				
			
		
			
				
					
				
			
		
			
				
					
				
			
		
			
				
					
				
					
				
			
		
			
				
					
				
			
		
			
				
					
				
			
		
			
				
					
				
					
						
					
				
					
				
			
		
			
				
					
				
			
		
			
				
					
				
			
		
			
				
					
				
			
		
			
				
					
				
					
				
			
		
			
				
					
				
					
				
			
		
			
				
					
				
					
				
			
		
			
				
					
				
					
				
			
		
			
				
					
				
					
				
			
		
			
				
					
				
			
		
			
				
					
				
			
		
			
				
					
				
					
						
					
				
			
		
			
				
					
				
			
		
		<!-- tag listing -->
		
			<!-- highlighting tags in current document -->
			<!-- checking if current page is not tag page -->
			
			 
				
			
			
			
				
					
				
			
			<li class="list--tags-item--active">
				<a href="/tags/css.html">css</a>
			</li>
		
			<!-- highlighting tags in current document -->
			<!-- checking if current page is not tag page -->
			
			 
				
			
			
			
				
					
				
			
			<li class="list--tags-item--active">
				<a href="/tags/oocss.html">oocss</a>
			</li>
		
			<!-- highlighting tags in current document -->
			<!-- checking if current page is not tag page -->
			
			 
				
			
			
			
				
					
				
			
			<li class="list--tags-item--active">
				<a href="/tags/translation.html">translation</a>
			</li>
		
			<!-- highlighting tags in current document -->
			<!-- checking if current page is not tag page -->
			
			 
				
			
			
			
				
			
			<li class="list--tags-item">
				<a href="/tags/svg.html">svg</a>
			</li>
		
			<!-- highlighting tags in current document -->
			<!-- checking if current page is not tag page -->
			
			 
				
			
			
			
				
			
			<li class="list--tags-item">
				<a href="/tags/layout.html">layout</a>
			</li>
		
			<!-- highlighting tags in current document -->
			<!-- checking if current page is not tag page -->
			
			 
				
			
			
			
				
			
			<li class="list--tags-item">
				<a href="/tags/kak-to-tak.html">kak-to-tak</a>
			</li>
		
			<!-- highlighting tags in current document -->
			<!-- checking if current page is not tag page -->
			
			 
				
			
			
			
				
			
			<li class="list--tags-item">
				<a href="/tags/gradient.html">gradient</a>
			</li>
		
			<!-- highlighting tags in current document -->
			<!-- checking if current page is not tag page -->
			
			 
				
			
			
			
				
			
			<li class="list--tags-item">
				<a href="/tags/form.html">form</a>
			</li>
		
			<!-- highlighting tags in current document -->
			<!-- checking if current page is not tag page -->
			
			 
				
			
			
			
				
			
			<li class="list--tags-item">
				<a href="/tags/font.html">font</a>
			</li>
		
	</ul>
</div>

<div class="l-space-l l-box l-line" rel="rss">
	<h5>RSS</h5>
	<ul class="list--simple t-size-s">
		<li>
			<a href="/posts.xml" class="t-link--sidebar">Блог</a>
		</li>
		<li>
			<a href="/folio.xml" class="t-link--sidebar">Фолио</a>
		</li>
	</ul>
</div>


				</div>
			</div>
			<div class="l-footer">
	<div class="l-sitewidth">
		<div class="l-space l-box l-line">
			Блог веб разработчика. В вебе с 2000 года.
			<a href="https://twitter.com/rooczebra/">Twitter</a>
		</div>
		<div class="l-space">
			&copy; Rooc 2014 | Никаких прав не защищено. Сделано на <a href='http://harpjs.com/'>Harpjs</a>
		</div>
	</div>
</div>
			
				<script type="text/javascript">
var disqus_shortname = 'roocblog';
(function () {
var s = document.createElement('script'); s.async = true;
s.type = 'text/javascript';
s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
				<script>

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-81406656-1', 'auto');
  ga('send', 'pageview');

</script>

			
		</div>
		

		<script src="/assets/js/bundle.js"></script>
	</body>

</html>