<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><title>Rooc :: Блог :: Модульный CSS и селекторы атрибутов</title><meta name="description" content="Модульный CSS на основе атрибутов"><meta name="keywords" content="css, modules, attributes, модульный css, атрибуты"><meta name="author" content="rooc"><meta name="viewport" content="width=device-width"><link rel="icon" href="/assets/img/favicon.png"><link href="http://fonts.googleapis.com/css?family=PT+Serif:400italic&subset=latin,cyrillic" rel="stylesheet"><link rel="stylesheet" href="/assets/css/styles.css"></head><body><div class="l-header"><div class="l-sitewidth"><a href="/" class="logo">Rooc</a><nav><ul class="nav"><li class="nav-item"><a href="/">Блог</a></li><li class="nav-item"><a href="/archive/">Архив</a></li><li class="nav-item"><a href="/links/">Полезное</a></li></ul></nav></div></div><div class="l-content"><div class="l-sitewidth"><div class="l-article"><div class="l-space"><div class="social"><a href="https://twitter.com/share" class="social-link" data-via="rooczebra" data-count="none"><i class="ifont--twitter"></i></a><script>!function(t,e,n){var r,s=t.getElementsByTagName(e)[0],a=/^http:/.test(t.location)?"http":"https";t.getElementById(n)||(r=t.createElement(e),r.id=n,r.async=!0,r.src=a+"://platform.twitter.com/widgets.js",s.parentNode.insertBefore(r,s))}(document,"script","twitter-wjs")</script></div><h1>Модульный CSS и селекторы атрибутов</h1><div class="meta"><span class="meta-date">Декабрь 13, 2014 </span>||  <span class="meta-tags"><a href="/tags/css.html">css</a> , <a href="/tags/oocss.html">oocss</a> , <a href="/tags/translation.html">translation</a> </span>||  <a class="meta-original" href="http://glenmaddern.com/articles/introducing-am-css" target="_blank">Introducing AM - Attribute Modules for CSS</a>  ||  <span class="meta-comments"><a href="#disqus_thread" data-disqus-identifier="attr-modules-disqus">комментарии</a></span></div><p>Несколько месяцев назад мне попалась <a href="http://csswizardry.com/2014/05/grouping-related-classes-in-your-markup/">статья Гарри Робертса</a> в которой он представил интересную концепцию работы с сопряженными классами в CSS. В этой статье он предложил использовать символы <code>[ ]</code> для группировки классов для того чтобы быстро распознать их смысл при беглом просмотре. Он приводит данный пример, утверждая что в таком виде декларация стилей становится более "распознавабельной":</p><pre><code class="language-html">&lt;div class="[ foo  foo--bar ]  [ baz  baz--foo ]">
</code></pre><p>Признаюсь, сначала я принял такой подход в штыки. Идея имен классов с именами <code>[ ]</code> которым к тому же не соотвествуют никакие стили, да еще повторяются внутри одного атрибута, которые имеют смысл только для человека и не для браузера, выглядит очень странной. Я собственно и по прежнему думаю также, но тем не менее, это заставило меня задуматься о верстке и семантике поглубже, поэтому - спасибо Гарри!</p><p>Пока я думал об этом я нашел что разные люди предлагали похожие подходы, например использовать <code>/</code> (<a href="http://beneverard.co.uk/blog/using-slashes-within-the-html-class-attribute/">Ben Everard</a>), или <code>|</code> (<a href="https://twitter.com/sn0lan/status/439384690680942592/">Steven Nolan</a>), но все эти способы оставляют ощущение искусственности.</p><blockquote><p>Как так вышло что у вас так много классов что вам нужны новые классы чтобы сделать их читабельными?</p></blockquote><p>Короче говоря это сумашествие. Хорошо читабельный HTML это конечно достойная цель, но такого рода приемы говорят что что то у нас фундаментально пошло не так с наименованием стилей.</p><h2>Больше классов против меньше классов</h2><p>Странная штука, но несмотря на то что обилие классов в разметке кажется мне не нормальным, люди типа Гарри чертовски убедительны. Исходя из принципов OOCSS или <a href="http://csswizardry.com/2012/04/the-single-responsibility-principle-applied-to-css/">Single Responsibility Principle</a>, а также из моего личного опыта работы со сложными сайтами, я могу сказать что есть определенная ценность в "дроблении" стилей, но тем не менее только недавно я нашел способ который меня удовлетворил.</p><p>Перед этим я адаптировал версию методологии БЭМ которая делает акцент на изоляции а не на повторном использовании - каждый новый блок по умолчанию не наследует никаких стилей, позволяя компоненту разрабатываться изолированно и избежать риска испортить что либо в другом месте сайта. Но недостаток такого подохода в том что в итоге вы обнаруживаете что у вас 10 различных стилей для ссылок, 12 оттенков голубого, 18 слегка отличающихся стилей кнопок. Николь Саливан, создатель OOCS, в своей фантастической <a href="https://www.youtube.com/watch?v=0NDyopLKE1w">презентации</a> в прошлом году в Мельбурне рассказала как часто такое случается и как это исправлять.</p><p>Для меня выходом, который меня устраивал, было использовать возможности препроцессоров для того чтобы совместить атомарность БЭМ и согласованность OOCSS. К примеру, вместо такого:</p><pre><code class="language-html">&lt;a class='btn large rounded'>
</code></pre><pre><code class="language-css">.btn { /* button styles */ }
.large { /* global large-type modifier */ }
.rounded { /* global rounded-border modifier */ }
</code></pre><p>имеем такое:</p><pre><code class="language-html">&lt;a class='btn btn--large btn--rounded'>
</code></pre><pre><code class="language-scss">.btn { /* button styles */ }
.btn--large {
  @extend %large-type;
}
.btn--rounded {
  @extend %rounded-borders;
}
</code></pre><p>В итоге я пришел к тому что у меня была кучка файлов типа <code>_typography.scss</code>, <code>_brand.scss</code>, которые позволяли мне более менее поддерживать фрагментацию и в то же время изоляцию отдельных компонентов. И все было ОК, до поры до времени.</p><h2>Модификаторы: как М ломает БЭМ</h2><p>Если вы изучаете вопрос наименования классов в CSS и поддержки стилей, вы неизбежно натолкнетесь на отличную статью Николаса Галахера <a href="http://nicolasgallagher.com/about-html-semantics-front-end-architecture/">"About HTML semantics and front-end architecture"</a>. Одна часть особенно привлекла мое внимание, то что он называет шаблоном "один класс" против "множественные классы". В вашей разметке потенциально может быть два таких варианта:</p><pre><code class="language-html">&lt;a class='btn--large'> &lt;!-- Single class -->
&lt;a class='btn btn--large'> &lt;!-- Multi class -->
</code></pre><p>Это соответствует двум подходам в CSS:</p><pre><code class="language-css">/* Single class */
.btn, .btn--large { /* base button styles */ }
.btn--large { /* large button styles */ }

/* Multi class */
.btn { /* base button styles */ }
.btn--large { /* large button styles */ }
</code></pre><p>Разница тут в том самостоятелен ли класс <code>btn--large</code> или он требует присутствия родительского класса <code>btn</code>. В шаблоне "один класс" он самостоятелен, это выглядит проще и удобнее, и страхует от случая когда вы забыли вписать второй класс. Плюс с функционалом препроцессоров <code>@extend</code> это выглядит совсем просто. Но, такой подход подвержен серьезному недостатку.</p><h2>Контекстные модификации</h2><p>Представим что все кнопки на сайте имеют какой то фоновый цвет, за исключением тех которые находятся в панели навигации в шапке сайта. В случае паттерна "множественные классы" вы добираетесь до кнопок в навигации так:</p><pre><code class="language-css">header > nav > .btn { background: none; }
</code></pre><p>В случае если вы используете паттерн с одним классом вы не знаете точно какой вариант кнопки вам надо перекрыть поэтому мы вынуждены поступать так:</p><pre><code class="language-scss">header > nav {
  .btn, .btn--large, .btn--rounded { background: none; }
}
</code></pre><p>Как можно догадаться это не идеально, каждый раз когда вы добавляете новый модификатор кнопки вам надо не забыть и вписать сюда этот класс. Это все не очень здраво, поэтому многие считают что надо вернуться к варианту множественных классов. (<a href="http://nicolasgallagher.com/about-html-semantics-front-end-architecture/">Nicholas Gallagher</a>, <a href="http://bensmithett.com/bem-modifiers-multiple-classes-vs-extend/">Ben Smithett</a>). Встречал и другие альтернативные варианты, метод <a href="http://viget.com/extend/bem-multiple-modifiers-and-experimenting-with-attribute-selectors">Томми Маршала</a> или <a href="http://benfrain.com/multiple-classes-ui-component-variations-wrong/">Бена Фрейна</a>, которые используют селектор атрибута <code>^=</code> которым можно проверить начинается ли атрибут определенной строкой, например:</p><pre><code class="language-html">&lt;a class='btn--large'>
</code></pre><pre><code class="language-css">[class^='btn'] { /* базовые стили кнопок */ }
.btn--large { /* модификатор для большой кнопки */ }
header > nav > [class^='btn'] { /* Перекрывает все кнопки */ }
</code></pre><p>Таким способом легко перекрыть стили шаблона "один класс", но все таки это слишком хрупкий способ чтобы рассматривать его серьезной альтернативой. Если к примеру у вас в стилях каким то образом первый класс оказался не <code>btn</code> то все ломается.</p><p>Я конечно ценю изобретательность такого подхода, но это тупик. Это как раз то место где я застрял, до тех пор пока мне не пришло в голову кое что.</p><h2>Какого</h2><pre><code>[class^='btn'] { /* base button styles */ }
.btn--large { /* large button styles */ }
header > nav > [class^='btn'] { /* Overrides for all buttons */ }
</code></pre><p>Это конечно удобный вариант для метода "один класс" но все таки это слишком хрупкая конструкция чтобы быть серьезной альтернативой. Если какой то другой класс окажется перед <code>btn--large</code> то вся конструкция летит к чертям. Плюс ко всему нет ясного способа как в этом случае иметь дело с модификатором модификатора типа <code>btn--large--rounded</code>.</p><p>Я ценю изобретательность этого метода но это тупик. И это то место где я застрял до момента когда кое что пришло мне в голову.</p><h2>А чего мы вообще приклеились<br>к атрибуту class?</h2><p>Пардон за мою тупость но кто нибудь может доказать мне что <code>class</code> это единственный атрибут который мы можем использовать для селекторов стилей? Вот что говорит <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#classes">спецификация HTML</a>:</p><blockquote><p><strong>3.2.5.7 The class attribute</strong></p><p>Атрибут, если определен, должен иметь значение, состоящее из группы разделенных пробелом имен представляющих различные классы к которым принадлежит элемент.</p><p>Нет никаких ограничений какие имена может использовать автор но рекомендуется использовать имена которые описывают природу или значение содержимого а не желаемый внешний вид содержимого.</p></blockquote><p>Ну да, это чудесно что мы используем атрибут класс для описания "природы содержимого", но все таки ощущение такое что мы хотим от него больше чем он может дать. Этот многострадальный атрибут содержит все, начиная от громоздких БЭМ имен типа <code>primary-nav__sub-nav--current</code> или вспомогательных классов типа <code>u-textTruncate</code> или <code>left clearfix</code>, до джаваскрипт указателей <code>js-whatevs</code>, в итоге мы тратим кучу времени на придумывание имен которые не конфликтуют один с другим и тем не менее читабельны.</p><p>С этим можно справится при помощи дисциплины и соглашений и с помощью разных техник, но правда в том что мы работаем в глобальном пространстве имен, и никакие соглашения не могут это изменить. А это как раз то что делает АМ особым.</p><p>Но прежде чем мы поговорим об этом нам нужно освежить одну не очень известную фишку в CSS.</p><h2>Магический селектор ~=</h2><p>Оказывается что браузеры аж с времен IE7 поддерживают мощнецкое правило называемое <strong>селектор атрибутов разделенных пробелом</strong>, описанную <a href="http://css-tricks.com/attribute-selectors/#rel-space">тут на CSS Tricks</a>. Он цепляет произвольные значения атрибутов, разделенных пробеламы, так как будто это и есть классы. К примеры следующие две строки идентичны:</p><pre><code class="language-css">.dat-class { /* dem styles */ };
[class~='dat-class'] { /* dem styles */ };
</code></pre><p>Точно также как для <code>&lt;div class="a b c "></code> не имеет значения в каком порядке стоят a, b или с, или что еще есть помимо них, также это не важно для селектора <code>~=</code>. Но этот селектор не ограничен атрибутом class, он работает точно также с любым другим атрибутом. И это ключевой момент в новом подходе.</p><p>"Модули атрибутов", или АМ, это по сути определение пространства имен в которых живут стили. Начнем с простого примера, колонки:</p><pre><code class="language-html">&lt;div class="row">
    &lt;div class="column-12">Full&lt;/div>
&lt;/div>
&lt;div class="row">
    &lt;div class="column-4">Thirds&lt;/div>
    &lt;div class="column-4">Thirds&lt;/div>
    &lt;div class="column-4">Thirds&lt;/div>
&lt;/div>
</code></pre><pre><code class="language-css">.row { /* max-width, clearfixes */ }
.column-1 { /* 1/12th width, floated */ }
.column-2 { /* 1/6th width, floated */ }
.column-3 { /* 1/4th width, floated */ }
.column-4 { /* 1/3rd width, floated */ }
.column-5 { /* 5/12th width, floated */ }
/* etc */
.column-12 { /* 100% width, floated */ }
</code></pre><p>Теперь построим это же самое на АМ. У нас есть два модуля, строки(rows) и колонки(columns). У строки нет вариаций, у колонок их 12.</p><pre><code class="language-html">&lt;div am-Row>
    &lt;div am-Column="12">Full&lt;/div>
&lt;/div>
&lt;div am-Row>
    &lt;div am-Column="4">Thirds&lt;/div>
    &lt;div am-Column="4">Thirds&lt;/div>
    &lt;div am-Column="4">Thirds&lt;/div>
&lt;/div>
</code></pre><pre><code class="language-css">[am-Row] { /* max-width, clearfixes */ }
[am-Column~="1"] { /* 1/12th width, floated */ }
[am-Column~="2"] { /* 1/6th width, floated */ }
[am-Column~="3"] { /* 1/4th width, floated */ }
[am-Column~="4"] { /* 1/3rd width, floated */ }
[am-Column~="5"] { /* 5/12th width, floated */ }
/* etc */
[am-Column~="12"] { /* 100% width, floated */ }
</code></pre><p>Первое что вы наверно заметили это префикс <code>am-</code>. Это важно чтобы не создать конфликтов с другими существующими атрибутами. Конечно можно использовать любой префикс, я пробовал <code>ui-</code>, <code>css-</code> и другие, но оставился на <code>am-</code> для данных примеров. Если валидность HTML критична для вас то можно использовать атрибут в виде <code>data-</code>, смысл тот же.</p><p>Второе что вы наверно заметили это значения атрибутов типа <code>1</code>, <code>2</code>. Если бы это были имена классов это было бы ужасно, они слишком общеупотребительные и шансы конфликтов велики. Но поскольку мы определили свое собственное пространство имен, мы можем использовать максимально короткие имена.</p><h2>Гибкость значений атрибутов</h2><p>На данный момент плюсы от нового способа минорные. Но поскольку каждый модуль задает свое пространство имен, давайте попробуем немного другую схему значений:</p><pre><code class="language-html">&lt;div am-Row>
    &lt;div am-Column>Full&lt;/div>
&lt;/div>
&lt;div am-Row>
    &lt;div am-Column="1/3">Thirds&lt;/div>
    &lt;div am-Column="1/3">Thirds&lt;/div>
    &lt;div am-Column="1/3">Thirds&lt;/div>
&lt;/div>
</code></pre><pre><code class="language-css">[am-Row] { /* max-width, clearfixes */ }
[am-Column] { /* 100% width, floated */ }
[am-Column~="1/12"] { /* 1/12th width */ }
[am-Column~="1/6"] { /* 1/6th width */ }
[am-Column~="1/4"] { /* 1/4th width */ }
[am-Column~="1/3"] { /* 1/3rd width */ }
[am-Column~="5/12"] { /* 5/12ths width */ }
/* etc */
</code></pre><p>Теперь мы можем легко использовать имена для наших конкретных нужд, ширина колонки 1/3 сразу же говорит что это значит, тогда как например 4 предполагает что мы помним что используем 12 колоночную сетку. Атрибут <code>column</code> без значения например означает колонку 100% ширины, и как бонус мы можем в атрибут без значения перенести всю повторяемую логику, (<code>float: left</code>) например.</p><h2>Определение стилей для атрибута и для его значений</h2><p>Это главная прелесть этого подхода. Наличие атрибута, например <code>am-Button</code>, само по себе может быть застилено. Конкретное значение атрибута модифицирует эти базовые стили.</p><p>В примере с сеткой выше мы делаем именно это: разметка <code>am-Column = "1/3"</code> подпадает сразу под оба селектора, и <code>[am-Column]</code> и <code>[am-Column~="1/3"]</code> , поэтому результат это базовые стили плюс вариации. Это избавляет от копирования классов или использования функционала <code>@extend</code>.</p><h2>"Без классовый" подход к БЕМ модификаторам</h2><p>Вернемся к спору между шаблоном "один класс" и "множественные классы". АМ предлагает способ без классов. Ну к примеру, для случая четырех вариантов кнопок разметка выглядит так:</p><pre><code class="language-html">&lt;a am-Button>Normal button&lt;/a>
&lt;a am-Button='large'>Large button&lt;/a>
&lt;a am-Button='rounded'>Rounded button&lt;/a>
&lt;a am-Button='large rounded'>Large rounded button&lt;/a>
</code></pre><pre><code class="language-css">[am-Button] { /* base button styles */ }
[am-Button~="large"] { /* large button styles */ }
[am-Button~="rounded"] { /* round button styles */ }
</code></pre><p>При помощи атрибута <code>am-Button</code>, мы можем разделить стили которые общие для всех кнопок и стили которые делают кнопку большой, или стили для скругленной кнопки. Мы можем не только спокойно комбинировать вариации кнопок (<code>am-Button = "large rounded"</code>), но мы можем выбирать сам атрибут для любых контекстных модификаций:</p><pre><code class="language-css">header > nav > [am-Button] { background: none; }
</code></pre><p>Не важно какой вариант кнопки у нас используется, или как много вариантов мы решим создать, мы можем выбрать все кнопки одним селектором <code>[am-Button]</code>, поэтому мы можем быть уверены что модификации будут валидными.</p><h2>AMCSS проект</h2><p>Я (<a href="http://glenmaddern.com/">Glen Maddern</a>), <a href="http://germanforblack.com/">Ben Schwarz</a> и <a href="http://bensmithett.com/">Ben Smithett</a> начали работу над спецификацией АМ. Если вы хотите узнать больше как эта техника расширяет блоки, элементы, точки перехода (breakpoints) и больше, поднимайте пожалуйста свой <a href="https://github.com/amcss/attribute-module-specification/issues">вопрос</a>.</p><p>Также мы сделали сайт с документацией, с разными примерами как использовать АМ, <a href="http://amcss.github.io/">amcss.github.io</a>. Если вам интересно внести свой вклад, сделать примеры или вы хотите показать нам свои варианты АМ библиотек, пишите нам на <a href="https://github.com/amcss/amcss.github.io">Гитхаб</a>.</p></div><div class="l-space l-box l-line"><div id="disqus_thread"></div></div><script>var disqus_shortname="roocblog",disqus_identifier="attr-modules-disqus";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div><div class="l-sidebar"><div class="l-space-l l-box l-line" rel="recent"><h5>Недавно</h5><ul class="list--simple t-size-s"><li><a href="/blog/no-preprocessors.html" class="t-link--sidebar">Почему я не использую препроцессоры</a></li><li><a href="/blog/using-svg.html" class="t-link--sidebar">Основы работы с SVG</a></li><li><a href="/blog/buttons.html" class="t-link--sidebar">Странный button</a></li><li><a href="/blog/oocss-utils.html" class="t-link--sidebar">OOCSS. Утилиты</a></li><li><a href="/blog/harpjs.html" class="t-link--sidebar">HarpJs</a></li></ul></div><div class="l-space-l l-box l-line" rel="tags"><h5>Теги</h5><ul class="list--tags t-size-s"><li class="list--tags-item--active"><a href="/tags/css.html">css</a></li><li class="list--tags-item--active"><a href="/tags/translation.html">translation</a></li><li class="list--tags-item--active"><a href="/tags/oocss.html">oocss</a></li><li class="list--tags-item"><a href="/tags/svg.html">svg</a></li><li class="list--tags-item"><a href="/tags/layout.html">layout</a></li><li class="list--tags-item"><a href="/tags/kak-to-tak.html">kak-to-tak</a></li><li class="list--tags-item"><a href="/tags/gradient.html">gradient</a></li><li class="list--tags-item"><a href="/tags/form.html">form</a></li><li class="list--tags-item"><a href="/tags/font.html">font</a></li></ul></div><div class="l-space-l l-box l-line" rel="rss"><h5>RSS</h5><ul class="list--simple t-size-s"><li><a href="/posts.xml" class="t-link--sidebar">Блог</a></li><li><a href="/folio.xml" class="t-link--sidebar">Фолио</a></li></ul></div></div></div><div class="l-footer"><div class="l-sitewidth"><div class="l-space l-box l-line">Блог веб разработчика. В вебе с 2000 года. <a href="https://twitter.com/rooczebra/">Twitter</a></div><div class="l-space">© Rooc 2014 | Никаких прав не защищено. Сделано на <a href="http://harpjs.com/">Harpjs</a></div></div></div><script>var disqus_shortname="roocblog";!function(){var e=document.createElement("script");e.async=!0,e.type="text/javascript",e.src="http://"+disqus_shortname+".disqus.com/count.js",(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(e)}()</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-81406656-1","auto"),ga("send","pageview")</script></div><script src="/assets/js/bundle.js"></script></body></html>